import { Core, EventName } from '../../globals/ts/enum';
import AbstractComponent from '../../globals/ts/abstract-component';
import Data from '../../globals/ts/data';
import EventHandler from '../../globals/ts/event-handler';
import Util from '../../globals/ts/util';
import WebComponentFactory from '../../globals/ts/web-component-factory';
export default class Modal extends AbstractComponent {
    constructor(element) {
        super(Modal, element);
        this.backdrop = null;
        this.dialog = null;
        this.ignoreBackdropClick = null;
        this.isShown = false;
        this.isTransitioning = false;
        this.dialog = this.element.querySelector(Modal.SELECTOR.dialog);
        Data.setData(element, Modal.DATA_KEY, this);
        this.registerEvents();
    }
    static init(options = {}) {
        return super.init(this, options, Modal.SELECTOR.default);
    }
    static getInstance(element) {
        return Data.getData(element, Modal.DATA_KEY);
    }
    enforceFocus() {
        EventHandler.off(document, Modal.EVENT.focusin); // Guard against infinite focus loop
        EventHandler.on(document, Modal.EVENT.focusin, event => {
            if (document !== event.target && this.element !== event.target && !this.element.contains(event.target)) {
                this.element.focus();
            }
        });
    }
    hideModal() {
        this.element.style.display = 'none';
        this.element.setAttribute('aria-hidden', '');
        this.element.removeAttribute('aria-modal');
        this.isTransitioning = false;
        this.showBackdrop();
    }
    removeBackdrop() {
        if (this.backdrop) {
            this.backdrop.parentNode.removeChild(this.backdrop);
            this.backdrop = null;
        }
    }
    setEscapeEvent() {
        if (this.isShown) {
            EventHandler.on(this.element, Modal.EVENT.keydownDismiss, event => {
                if (event.which === Modal.ESCAPE_KEYCODE) {
                    event.preventDefault();
                    this.hide();
                }
            });
        }
        else {
            EventHandler.off(this.element, Modal.EVENT.keydownDismiss);
        }
    }
    showBackdrop(callback) {
        const animate = this.element.classList.contains(Modal.CLASSNAME.fade) ? Modal.CLASSNAME.fade : '';
        if (this.isShown) {
            this.backdrop = document.createElement('div');
            this.backdrop.className = Modal.CLASSNAME.backdrop;
            if (animate) {
                this.backdrop.classList.add(animate);
            }
            document.body.appendChild(this.backdrop);
            EventHandler.on(this.element, Modal.EVENT.clickDismiss, event => {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false;
                    return;
                }
                if (event.target !== event.currentTarget) {
                    return;
                }
                this.hide();
            });
            if (animate) {
                Util.reflow(this.backdrop);
            }
            this.backdrop.classList.add(Modal.CLASSNAME.show);
            if (!callback) {
                return;
            }
            if (!animate) {
                callback();
                return;
            }
            const backdropTransitionDuration = Util.getTransitionDurationFromElement(this.backdrop);
            EventHandler.one(this.backdrop, Util.TRANSITION_END, callback);
            Util.emulateTransitionEnd(this.backdrop, backdropTransitionDuration);
        }
        else if (!this.isShown && this.backdrop) {
            this.backdrop.classList.remove(Modal.CLASSNAME.show);
            const callbackRemove = () => {
                this.removeBackdrop();
                if (callback) {
                    callback();
                }
            };
            if (this.element.classList.contains(Modal.CLASSNAME.fade)) {
                const backdropTransitionDuration = Util.getTransitionDurationFromElement(this.backdrop);
                EventHandler.one(this.backdrop, Util.TRANSITION_END, callbackRemove);
                Util.emulateTransitionEnd(this.backdrop, backdropTransitionDuration);
            }
            else {
                callbackRemove();
            }
        }
        else if (callback) {
            callback();
        }
    }
    showElement() {
        const transition = this.element.classList.contains(Modal.CLASSNAME.fade);
        if (!this.element.parentNode || this.element.parentNode.nodeType !== Node.ELEMENT_NODE) {
            // Don't move modal's DOM position
            document.body.appendChild(this.element);
        }
        this.element.style.display = 'block';
        this.element.removeAttribute('aria-hidden');
        this.element.setAttribute('aria-modal', '');
        this.element.scrollTop = 0;
        if (transition) {
            Util.reflow(this.element);
        }
        this.element.classList.add(Modal.CLASSNAME.show);
        this.enforceFocus();
        const transitionComplete = () => {
            this.element.focus();
            this.isTransitioning = false;
        };
        if (transition) {
            const transitionDuration = Util.getTransitionDurationFromElement(this.dialog);
            EventHandler.one(this.dialog, Util.TRANSITION_END, transitionComplete);
            Util.emulateTransitionEnd(this.dialog, transitionDuration);
        }
        else {
            transitionComplete();
        }
    }
    dispose() {
        Data.removeData(this.element, Modal.DATA_KEY);
        /**
         * `document` has 2 events `Modal.EVENT.FOCUSIN` and `Modal.EVENT.CLICK_DATA_API`
         * Do not move `document` in `htmlElements` array
         * It will remove `Modal.EVENT.CLICK_DATA_API` event that should remain
         */
        EventHandler.off(document, Modal.EVENT.focusin);
        this.element = null;
        this.dialog = null;
        this.backdrop = null;
        this.isShown = null;
        this.ignoreBackdropClick = null;
        this.isTransitioning = null;
    }
    hide(event) {
        if (event) {
            event.preventDefault();
        }
        if (!this.isShown || this.isTransitioning) {
            return;
        }
        this.isShown = false;
        const transition = this.element.classList.contains(Modal.CLASSNAME.fade);
        if (transition) {
            this.isTransitioning = true;
        }
        this.setEscapeEvent();
        EventHandler.off(document, Modal.EVENT.focusin);
        this.element.classList.remove(Modal.CLASSNAME.show);
        EventHandler.off(this.element, Modal.EVENT.clickDismiss);
        EventHandler.off(this.dialog, Modal.EVENT.mousedownDismiss);
        if (transition) {
            const transitionDuration = Util.getTransitionDurationFromElement(this.element);
            EventHandler.one(this.element, Util.TRANSITION_END, () => this.hideModal());
            Util.emulateTransitionEnd(this.element, transitionDuration);
        }
        else {
            this.hideModal();
        }
    }
    show() {
        if (this.isShown || this.isTransitioning) {
            return;
        }
        if (this.element.classList.contains(Modal.CLASSNAME.fade)) {
            this.isTransitioning = true;
        }
        this.isShown = true;
        this.setEscapeEvent();
        EventHandler.on(this.element, Modal.EVENT.clickDismiss, Modal.SELECTOR.dataDismiss, event => this.hide(event));
        EventHandler.on(this.dialog, Modal.EVENT.mousedownDismiss, () => {
            EventHandler.one(this.element, Modal.EVENT.mouseupDismiss, event => {
                if (event.target.isEqualNode(this.element)) {
                    this.ignoreBackdropClick = true;
                }
            });
        });
        this.showBackdrop(() => this.showElement());
    }
    toggle() {
        if (this.isShown) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */
    registerEvents() {
        EventHandler.on(document, Modal.EVENT.clickDataApi, Modal.SELECTOR.dataToggle, (event) => {
            let target;
            const currentTarget = event.currentTarget;
            const selector = Util.getSelectorFromElement(event.target);
            if (selector) {
                target = document.querySelector(selector);
            }
            if (currentTarget.tagName === 'A' || currentTarget.tagName === 'AREA') {
                event.preventDefault();
            }
            const component = Modal.getInstance(target);
            if (component) {
                component.toggle();
            }
        });
    }
}
Modal.NAME = `${Core.KEY_PREFIX}-modal`;
Modal.DATA_KEY = `${Core.KEY_PREFIX}.modal`;
Modal.EVENT_KEY = `.${Modal.DATA_KEY}`;
Modal.DATA_API_KEY = Core.KEY_PREFIX;
Modal.ESCAPE_KEYCODE = 27; // KeyboardEventName.which value for Escape (Esc) key
Modal.CLASSNAME = {
    backdrop: `${Core.KEY_PREFIX}-modal__backdrop`,
    fade: 'fade',
    show: 'show'
};
Modal.SELECTOR = {
    default: `.${Modal.NAME}`,
    dataDismiss: '[data-dismiss="modal"]',
    dataToggle: '[data-toggle="modal"]',
    modalBody: `.${Core.KEY_PREFIX}-modal__body`,
    dialog: `.${Core.KEY_PREFIX}-modal__dialog`
};
Modal.EVENT = {
    show: `${EventName.show}${Modal.EVENT_KEY}`,
    shown: `${EventName.shown}${Modal.EVENT_KEY}`,
    focusin: `${EventName.focusin}${Modal.EVENT_KEY}`,
    hide: `${EventName.hide}${Modal.EVENT_KEY}`,
    hidden: `${EventName.hidden}${Modal.EVENT_KEY}`,
    keydownDismiss: `${EventName.keydown}.dismiss${Modal.EVENT_KEY}`,
    clickDismiss: `${EventName.click}.dismiss${Modal.EVENT_KEY}`,
    clickDataApi: `${EventName.click}${Modal.EVENT_KEY}${Modal.DATA_API_KEY}`,
    mouseupDismiss: `${EventName.mouseup}.dismiss${Modal.EVENT_KEY}`,
    mousedownDismiss: `${EventName.mousedown}.dismiss${Modal.EVENT_KEY}`
};
export class ModalWC extends WebComponentFactory {
    constructor() {
        super(Modal);
    }
    static init() {
        WebComponentFactory.init(ModalWC);
    }
}
ModalWC.TAG_NAME = Modal.NAME;
//# sourceMappingURL=index.js.map