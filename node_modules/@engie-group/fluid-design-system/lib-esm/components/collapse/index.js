/**
 * --------------------------------------------------------------------------
 * NJ: collapse.ts
 * --------------------------------------------------------------------------
 */
import { Core, EventName } from '../../globals/ts/enum';
import AbstractComponent from '../../globals/ts/abstract-component';
import Data from '../../globals/ts/data';
import EventHandler from '../../globals/ts/event-handler';
import Manipulator from '../../globals/ts/manipulator';
import Util from '../../globals/ts/util';
import WebComponentFactory from '../../globals/ts/web-component-factory';
export default class Collapse extends AbstractComponent {
    constructor(element, options = {}) {
        super(Collapse, element, Collapse.getOptions(options));
        this.element = element;
        this.isTransitioning = false;
        this.triggerArray = Util.makeArray(document.querySelectorAll(`${Collapse.SELECTOR.dataToggle}[href="#${element.id}"],` +
            `${Collapse.SELECTOR.dataToggle}[data-target="#${element.id}"]`));
        const toggleList = Util.makeArray(document.querySelectorAll(Collapse.SELECTOR.dataToggle));
        for (let i = 0, len = toggleList.length; i < len; i++) {
            const elem = toggleList[i];
            const selector = Util.getSelectorFromElement(elem);
            const filterElement = Util.makeArray(document.querySelectorAll(selector)).filter(foundElem => foundElem === element);
            if (selector !== null && filterElement.length) {
                this.selector = selector;
                this.triggerArray.push(elem);
            }
        }
        this.parent = this.options.parent ? this.getParent() : null;
        if (!this.options.parent) {
            this.addAriaAndCollapsedClass(this.element, this.triggerArray);
        }
        Data.setData(element, Collapse.DATA_KEY, this);
        if (this.options.toggle) {
            this.toggle();
        }
        Data.setData(element, Collapse.DATA_KEY, this);
        this.registerEvents();
    }
    toggle() {
        if (this.element.classList.contains(Collapse.CLASS_NAME.show)) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    show() {
        if (this.isTransitioning || this.element.classList.contains(Collapse.CLASS_NAME.show)) {
            return;
        }
        let actives;
        let activesData;
        if (this.parent) {
            actives = Util.makeArray(this.parent.querySelectorAll(Collapse.SELECTOR.actives)).filter(elem => {
                if (typeof this.options.parent === 'string') {
                    return elem.getAttribute('data-parent') === this.options.parent;
                }
                return elem.classList.contains(Collapse.CLASS_NAME.collapse);
            });
            if (actives.length === 0) {
                actives = null;
            }
        }
        const container = document.querySelector(this.selector);
        if (actives) {
            const tempActiveData = actives.filter(elem => container !== elem);
            activesData = tempActiveData[0] ? Data.getData(tempActiveData[0], Collapse.DATA_KEY) : null;
            if (activesData && activesData.isTransitioning) {
                return;
            }
        }
        const startEvent = EventHandler.trigger(this.element, Collapse.EVENT.show);
        if (startEvent.defaultPrevented) {
            return;
        }
        if (actives) {
            actives.forEach(elemActive => {
                if (container !== elemActive) {
                    Collapse.collapseInterface(elemActive, 'hide');
                }
                if (!activesData) {
                    Data.setData(elemActive, Collapse.DATA_KEY, null);
                }
            });
        }
        const dimension = this.getDimension();
        this.element.classList.remove(Collapse.CLASS_NAME.collapse);
        this.element.classList.add(Collapse.CLASS_NAME.collapsing);
        this.element.style[dimension] = 0;
        if (this.triggerArray.length) {
            this.triggerArray.forEach(element => {
                element.classList.remove(Collapse.CLASS_NAME.collapsed);
                element.setAttribute('aria-expanded', 'true');
            });
        }
        this.setTransitioning(true);
        const complete = () => {
            this.element.classList.remove(Collapse.CLASS_NAME.collapsing);
            this.element.classList.add(Collapse.CLASS_NAME.collapse);
            this.element.classList.add(Collapse.CLASS_NAME.show);
            this.element.style[dimension] = '';
            this.setTransitioning(false);
            EventHandler.trigger(this.element, Collapse.EVENT.shown);
        };
        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        const scrollSize = `scroll${capitalizedDimension}`;
        const transitionDuration = Util.getTransitionDurationFromElement(this.element);
        EventHandler.one(this.element, Util.TRANSITION_END, complete);
        Util.emulateTransitionEnd(this.element, transitionDuration);
        this.element.style[dimension] = `${this.element[scrollSize]}px`;
    }
    hide() {
        if (this.isTransitioning || !this.element.classList.contains(Collapse.CLASS_NAME.show)) {
            return;
        }
        const startEvent = EventHandler.trigger(this.element, Collapse.EVENT.hide);
        if (startEvent.defaultPrevented) {
            return;
        }
        const dimension = this.getDimension();
        this.element.style[dimension] = `${this.element.getBoundingClientRect()[dimension]}px`;
        Util.reflow(this.element);
        this.element.classList.add(Collapse.CLASS_NAME.collapsing);
        this.element.classList.remove(Collapse.CLASS_NAME.collapse);
        this.element.classList.remove(Collapse.CLASS_NAME.show);
        const triggerArrayLength = this.triggerArray.length;
        if (triggerArrayLength > 0) {
            for (let i = 0; i < triggerArrayLength; i++) {
                const trigger = this.triggerArray[i];
                const selector = Util.getSelectorFromElement(trigger);
                if (selector !== null) {
                    const elem = document.querySelector(selector);
                    if (!elem.classList.contains(Collapse.CLASS_NAME.show)) {
                        trigger.classList.add(Collapse.CLASS_NAME.collapsed);
                        trigger.setAttribute('aria-expanded', 'false');
                    }
                }
            }
        }
        this.setTransitioning(true);
        const complete = () => {
            this.setTransitioning(false);
            this.element.classList.remove(Collapse.CLASS_NAME.collapsing);
            this.element.classList.add(Collapse.CLASS_NAME.collapse);
            EventHandler.trigger(this.element, Collapse.EVENT.hidden);
        };
        this.element.style[dimension] = '';
        const transitionDuration = Util.getTransitionDurationFromElement(this.element);
        EventHandler.one(this.element, Util.TRANSITION_END, complete);
        Util.emulateTransitionEnd(this.element, transitionDuration);
    }
    setTransitioning(isTransitioning) {
        this.isTransitioning = isTransitioning;
    }
    dispose() {
        Data.removeData(this.element, Collapse.DATA_KEY);
        this.options = null;
        this.parent = null;
        this.element = null;
        this.triggerArray = null;
        this.isTransitioning = null;
    }
    getDimension() {
        const hasWidth = this.element.classList.contains(Collapse.DIMENSION.width);
        return hasWidth ? Collapse.DIMENSION.width : Collapse.DIMENSION.height;
    }
    getParent() {
        let parent;
        if (Util.isElement(this.options.parent)) {
            parent = this.options.parent;
        }
        else if (this.options.parent) {
            parent = document.querySelector(this.options.parent);
        }
        const selector = `[data-toggle="collapse"][data-parent="${this.options.parent}"]`;
        Util.makeArray(parent.querySelectorAll(selector)).forEach(element => {
            this.addAriaAndCollapsedClass(Collapse.getTargetFromElement(element), [element]);
        });
        return parent;
    }
    addAriaAndCollapsedClass(element, triggerArray) {
        if (element) {
            const isOpen = element.classList.contains(Collapse.CLASS_NAME.show);
            if (triggerArray.length) {
                triggerArray.forEach(elem => {
                    if (!isOpen) {
                        elem.classList.add(Collapse.CLASS_NAME.collapsed);
                    }
                    else {
                        elem.classList.remove(Collapse.CLASS_NAME.collapsed);
                    }
                    elem.setAttribute('aria-expanded', isOpen);
                });
            }
        }
    }
    static getOptions(options) {
        options = Object.assign(Object.assign({}, Collapse.DEFAULT_OPTIONS), options);
        options.toggle = Boolean(options.toggle); // Coerce string values
        Util.typeCheckConfig(Collapse.NAME, options, Collapse.DEFAULT_TYPE);
        return options;
    }
    static getTargetFromElement(element) {
        const selector = Util.getSelectorFromElement(element);
        return selector ? document.querySelector(selector) : null;
    }
    static collapseInterface(element, options) {
        let data = Data.getData(element, Collapse.DATA_KEY);
        const cfg = Object.assign(Object.assign(Object.assign({}, Collapse.DEFAULT_OPTIONS), Manipulator.getDataAttributes(element)), (typeof options === 'object' && options ? options : {}));
        if (!data && cfg.toggle && /show|hide/.test(options)) {
            cfg.toggle = false;
        }
        if (!data) {
            data = new Collapse(element, cfg);
        }
        if (typeof options === 'string') {
            if (typeof data[options] === 'undefined') {
                throw new Error(`No method named "${options}"`);
            }
            data[options]();
        }
    }
    static getInstance(element) {
        return Data.getData(element, Collapse.DATA_KEY);
    }
    static init(options = {}) {
        return super.init(this, options, Collapse.SELECTOR.default);
    }
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */
    registerEvents() {
        EventHandler.on(document, Collapse.EVENT.clickDataApi, Collapse.SELECTOR.dataToggle, function (event) {
            // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
            if (event.target.tagName === 'A') {
                event.preventDefault();
            }
            const triggerData = Manipulator.getDataAttributes(this);
            const selector = Util.getSelectorFromElement(this);
            const selectorElements = Util.makeArray(document.querySelectorAll(selector));
            selectorElements.forEach(element => {
                const data = Collapse.getInstance(element);
                let options;
                if (data) {
                    // update parent attribute
                    if (data.parent === null && typeof triggerData.parent === 'string') {
                        data.options.parent = triggerData.parent;
                        data.parent = data.getParent();
                    }
                    options = 'toggle';
                }
                else {
                    options = triggerData;
                }
                Collapse.collapseInterface(element, options);
            });
        });
    }
}
Collapse.NAME = `${Core.KEY_PREFIX}-collapse`;
Collapse.DATA_KEY = `${Core.KEY_PREFIX}.collapse`;
Collapse.EVENT_KEY = `.${Collapse.DATA_KEY}`;
Collapse.DATA_API_KEY = Core.KEY_PREFIX;
Collapse.CLASS_NAME = {
    show: 'show',
    collapse: `${Core.KEY_PREFIX}-collapse`,
    collapsing: `${Core.KEY_PREFIX}-collapsing`,
    collapsed: `${Core.KEY_PREFIX}-collapsed`
};
Collapse.EVENT = {
    show: `${EventName.show}${Collapse.EVENT_KEY}`,
    shown: `${EventName.shown}${Collapse.EVENT_KEY}`,
    hide: `${EventName.hide}${Collapse.EVENT_KEY}`,
    hidden: `${EventName.hidden}${Collapse.EVENT_KEY}`,
    clickDataApi: `${EventName.click}${Collapse.EVENT_KEY}${Collapse.DATA_API_KEY}`
};
Collapse.DEFAULT_OPTIONS = {
    toggle: false,
    parent: ''
};
Collapse.DEFAULT_TYPE = {
    toggle: 'boolean',
    parent: '(string|element)'
};
Collapse.DIMENSION = {
    width: 'width',
    height: 'height'
};
Collapse.SELECTOR = {
    default: `.${Collapse.CLASS_NAME.collapse}`,
    actives: `.${Collapse.CLASS_NAME.show}, .${Collapse.CLASS_NAME.collapsing}`,
    dataToggle: '[data-toggle="collapse"]'
};
export class CollapseWC extends WebComponentFactory {
    constructor() {
        super(Collapse);
    }
    static init() {
        WebComponentFactory.init(CollapseWC);
    }
}
CollapseWC.TAG_NAME = Collapse.NAME;
//# sourceMappingURL=index.js.map