/**
 * --------------------------------------------------------------------------
 * NJ : abstract-form-base-input.ts
 * --------------------------------------------------------------------------
 */
import AbstractFormBase from './abstract-form-base';
import EventHandler from './event-handler';
import Manipulator from './manipulator';
import Testing from './testing';
export default class AbstractFormBaseInput extends AbstractFormBase {
    constructor(component, element, options = {}, properties = {}) {
        super(component, element, Manipulator.extend(true, AbstractFormBaseInput.DEFAULT_OPTIONS, options), properties);
        // The layout has to contain the class .nj-form-group if needed. The wrapper will not be automatically added
        this.njFormGroup = this.resolveNJFormGroup();
        if (this.njFormGroup) {
            // Resolve and mark the njLabel if necessary as defined by the config
            this.resolveNJLabel();
            // Signal to the nj-form-group that a form-control-* variation is being used
            this.resolveNJFormGroupSizing();
            this.addFocusListener();
            this.addChangeListener();
            if (this.isEmpty()) {
                this.removeIsFilled();
            }
            else {
                this.addIsFilled();
            }
        }
    }
    addFocusListener() {
        EventHandler.on(this.element, 'focus', () => {
            this.addFormGroupFocus();
        });
        EventHandler.on(this.element, 'blur', () => {
            this.removeFormGroupFocus();
        });
    }
    addChangeListener() {
        EventHandler.on(this.element, 'keydown paste', event => {
            if (Testing.isChar(event)) {
                this.addIsFilled();
            }
        });
        EventHandler.on(this.element, 'keyup change', () => {
            // make sure empty is added back when there is a programmatic value change.
            //  NOTE: programmatic changing of value using $.val() must trigger the change event i.e. $.val('x').trigger('change')
            if (this.isEmpty()) {
                this.removeIsFilled();
            }
            else {
                this.addIsFilled();
            }
            if (this.options.validate) {
                // Validation events do not bubble, so they must be attached directly to the text: http://jsfiddle.net/PEpRM/1/
                //  Further, even the bind method is being caught, but since we are already calling #checkValidity here, just alter
                //  the form-group on change.
                //
                // NOTE: I'm not sure we should be intervening regarding validation, this seems better as a README and snippet of code.
                //        BUT, I've left it here for backwards compatibility.
                const isValid = typeof this.element[0].checkValidity === 'undefined' || this.element[0].checkValidity();
                if (isValid) {
                    this.removeHasDanger();
                }
                else {
                    this.addHasDanger();
                }
            }
        });
    }
    addHasDanger() {
        this.njFormGroup.classList.add(AbstractFormBaseInput.CLASS_NAME.hasDanger);
    }
    removeHasDanger() {
        this.njFormGroup.classList.remove(AbstractFormBaseInput.CLASS_NAME.hasDanger);
    }
    isEmpty() {
        return this.element.value === null || typeof this.element.value === 'undefined' || this.element.value === '';
    }
    // Will add nj-form-group to form-group or create a nj-form-group if necessary
    resolveNJFormGroup() {
        return this.findFormGroup(this.options.njFormGroup.required);
    }
    // Demarcation element (e.g. first child of a form-group)
    // Subclasses such as file inputs may have different structures
    outerElement() {
        return this.element;
    }
    // Will add nj-label to nj-form-group if not already specified
    resolveNJLabel() {
        let label = this.njFormGroup.querySelectorAll(AbstractFormBaseInput.INPUT_SELECTOR.njLabelWildcard);
        if (label.length === 0) {
            // we need to find it based on the configured selectors
            label = this.findLabel(this.options.label.required);
            if (label !== null && label.length > 1) {
                // a candidate label was found, add the configured default class name
                label.forEach(el => {
                    el.classList.add(this.options.label.className);
                });
            }
        }
    }
    // Find nj-label variant based on the config selectors
    findLabel(raiseError = true) {
        let label = null;
        let i = 0;
        let selector;
        let labelFound = false;
        do {
            selector = this.options.label.selectors[i];
            try {
                label = this.njFormGroup.querySelectorAll(selector);
            }
            catch (e) {
                // handle the SyntaxError exception, if the selector is not understand by the browser.
                // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll
                label = null;
            }
            labelFound = label !== null && label.length > 0;
            i++;
        } while (!labelFound && i < this.options.label.selectors.length);
        if (!labelFound && raiseError) {
            console.error(`Failed to find ${AbstractFormBaseInput.INPUT_SELECTOR.njLabelWildcard} within nj-form-group for ${Testing.describe(this.element)}`);
        }
        return label;
    }
    // Due to the interconnected nature of labels/inputs/help-blocks, signal the nj-form-group-* size variation based on
    //  a found form-control-* size
    resolveNJFormGroupSizing() {
        if (!this.options.convertInputSizeVariations) {
            return;
        }
        // Modification - Change text-sm/lg to form-group-sm/lg instead (preferred standard and simpler css/less variants)
        for (const inputSize in AbstractFormBaseInput.FORM_CONTROL_SIZE_MARKERS) {
            if (this.element.classList.contains(inputSize)) {
                // this.element.classList.remove(inputSize)
                this.njFormGroup.classList.add(AbstractFormBaseInput.FORM_CONTROL_SIZE_MARKERS[inputSize]);
            }
        }
    }
}
AbstractFormBaseInput.CLASS_NAME = {
    njFormGroup: 'nj-form-group',
    njLabel: 'nj-label',
    njLabelStatic: 'nj-label-static',
    njLabelPlaceholder: 'nj-label-placeholder',
    njLabelFloating: 'nj-label-floating',
    hasDanger: 'has-danger',
    isFilled: 'is-filled',
    isFocused: 'is-focused',
    inputGroup: 'input-group'
};
AbstractFormBaseInput.INPUT_SELECTOR = {
    njFormGroup: `.${AbstractFormBaseInput.CLASS_NAME.njFormGroup}`,
    njLabelWildcard: `label[class^='${AbstractFormBaseInput.CLASS_NAME.njLabel}'], label[class*=' ${AbstractFormBaseInput.CLASS_NAME.njLabel}']`
};
AbstractFormBaseInput.DEFAULT_OPTIONS = {
    validate: false,
    njFormGroup: {
        template: 'span',
        templateClass: `${AbstractFormBaseInput.CLASS_NAME.njFormGroup}`
    },
    label: {
        required: false,
        selectors: [
            '.form-control-label',
            ':scope > label' // usual case for text inputs, first child.  Deeper would find toggle labels so don't do that.
        ],
        className: AbstractFormBaseInput.CLASS_NAME.njLabelStatic
    },
    requiredClasses: [],
    convertInputSizeVariations: true
};
AbstractFormBaseInput.FORM_CONTROL_SIZE_MARKERS = {
    'form-control-lg': 'nj-form-group-lg',
    'form-control-sm': 'nj-form-group-sm'
};
//# sourceMappingURL=abstract-form-base-input.js.map