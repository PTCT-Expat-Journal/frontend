import { Core, EventName } from '../../globals/ts/enum';
import AbstractComponent from '../../globals/ts/abstract-component';
import Data from '../../globals/ts/data';
import EventHandler from '../../globals/ts/event-handler';
import Util from '../../globals/ts/util';
import WebComponentFactory from '../../globals/ts/web-component-factory';

export default class Modal extends AbstractComponent {
  static readonly NAME = `${Core.KEY_PREFIX}-modal`;
  protected static readonly DATA_KEY = `${Core.KEY_PREFIX}.modal`;
  protected static readonly EVENT_KEY = `.${Modal.DATA_KEY}`;
  protected static readonly DATA_API_KEY = Core.KEY_PREFIX;
  private static readonly ESCAPE_KEYCODE = 27; // KeyboardEventName.which value for Escape (Esc) key

  private static readonly CLASSNAME = {
    backdrop: `${Core.KEY_PREFIX}-modal__backdrop`,
    fade: 'fade',
    show: 'show'
  };

  protected static readonly SELECTOR = {
    default: `.${Modal.NAME}`,
    dataDismiss: '[data-dismiss="modal"]',
    dataToggle: '[data-toggle="modal"]',
    modalBody: `.${Core.KEY_PREFIX}-modal__body`,
    dialog: `.${Core.KEY_PREFIX}-modal__dialog`
  };

  private static readonly EVENT = {
    show: `${EventName.show}${Modal.EVENT_KEY}`,
    shown: `${EventName.shown}${Modal.EVENT_KEY}`,
    focusin: `${EventName.focusin}${Modal.EVENT_KEY}`,
    hide: `${EventName.hide}${Modal.EVENT_KEY}`,
    hidden: `${EventName.hidden}${Modal.EVENT_KEY}`,
    keydownDismiss: `${EventName.keydown}.dismiss${Modal.EVENT_KEY}`,
    clickDismiss: `${EventName.click}.dismiss${Modal.EVENT_KEY}`,
    clickDataApi: `${EventName.click}${Modal.EVENT_KEY}${Modal.DATA_API_KEY}`,
    mouseupDismiss: `${EventName.mouseup}.dismiss${Modal.EVENT_KEY}`,
    mousedownDismiss: `${EventName.mousedown}.dismiss${Modal.EVENT_KEY}`
  };

  private backdrop: HTMLElement = null;
  private dialog: Element = null;
  private ignoreBackdropClick = null;
  private isShown = false;
  private isTransitioning = false;

  constructor(element: HTMLElement) {
    super(Modal, element);

    this.dialog = this.element.querySelector(Modal.SELECTOR.dialog);
    Data.setData(element, Modal.DATA_KEY, this);

    this.registerEvents();
  }

  static init(options = {}): Modal[] {
    return super.init(this, options, Modal.SELECTOR.default) as Modal[];
  }

  static getInstance(element: HTMLElement): Modal {
    return Data.getData(element, Modal.DATA_KEY) as Modal;
  }

  private enforceFocus(): void {
    EventHandler.off(document, Modal.EVENT.focusin); // Guard against infinite focus loop

    EventHandler.on(document, Modal.EVENT.focusin, event => {
      if (document !== event.target && this.element !== event.target && !this.element.contains(event.target)) {
        this.element.focus();
      }
    });
  }

  private hideModal(): void {
    this.element.style.display = 'none';
    this.element.setAttribute('aria-hidden', '');
    this.element.removeAttribute('aria-modal');
    this.isTransitioning = false;
    this.showBackdrop();
  }

  private removeBackdrop(): void {
    if (this.backdrop) {
      this.backdrop.parentNode.removeChild(this.backdrop);
      this.backdrop = null;
    }
  }

  private setEscapeEvent(): void {
    if (this.isShown) {
      EventHandler.on(this.element, Modal.EVENT.keydownDismiss, event => {
        if (event.which === Modal.ESCAPE_KEYCODE) {
          event.preventDefault();
          this.hide();
        }
      });
    } else {
      EventHandler.off(this.element, Modal.EVENT.keydownDismiss);
    }
  }

  private showBackdrop(callback?: Function): void {
    const animate = this.element.classList.contains(Modal.CLASSNAME.fade) ? Modal.CLASSNAME.fade : '';

    if (this.isShown) {
      this.backdrop = document.createElement('div');
      this.backdrop.className = Modal.CLASSNAME.backdrop;

      if (animate) {
        this.backdrop.classList.add(animate);
      }

      document.body.appendChild(this.backdrop);

      EventHandler.on(this.element, Modal.EVENT.clickDismiss, event => {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }
        if (event.target !== event.currentTarget) {
          return;
        }
        this.hide();
      });

      if (animate) {
        Util.reflow(this.backdrop);
      }

      this.backdrop.classList.add(Modal.CLASSNAME.show);

      if (!callback) {
        return;
      }

      if (!animate) {
        callback();
        return;
      }

      const backdropTransitionDuration = Util.getTransitionDurationFromElement(this.backdrop);

      EventHandler.one(this.backdrop, Util.TRANSITION_END, callback);
      Util.emulateTransitionEnd(this.backdrop, backdropTransitionDuration);
    } else if (!this.isShown && this.backdrop) {
      this.backdrop.classList.remove(Modal.CLASSNAME.show);

      const callbackRemove = (): void => {
        this.removeBackdrop();
        if (callback) {
          callback();
        }
      };

      if (this.element.classList.contains(Modal.CLASSNAME.fade)) {
        const backdropTransitionDuration = Util.getTransitionDurationFromElement(this.backdrop);

        EventHandler.one(this.backdrop, Util.TRANSITION_END, callbackRemove);
        Util.emulateTransitionEnd(this.backdrop, backdropTransitionDuration);
      } else {
        callbackRemove();
      }
    } else if (callback) {
      callback();
    }
  }

  private showElement(): void {
    const transition = this.element.classList.contains(Modal.CLASSNAME.fade);

    if (!this.element.parentNode || this.element.parentNode.nodeType !== Node.ELEMENT_NODE) {
      // Don't move modal's DOM position
      document.body.appendChild(this.element);
    }

    this.element.style.display = 'block';
    this.element.removeAttribute('aria-hidden');
    this.element.setAttribute('aria-modal', '');

    this.element.scrollTop = 0;

    if (transition) {
      Util.reflow(this.element);
    }

    this.element.classList.add(Modal.CLASSNAME.show);

    this.enforceFocus();

    const transitionComplete = (): void => {
      this.element.focus();
      this.isTransitioning = false;
    };

    if (transition) {
      const transitionDuration = Util.getTransitionDurationFromElement(this.dialog);

      EventHandler.one(this.dialog, Util.TRANSITION_END, transitionComplete);
      Util.emulateTransitionEnd(this.dialog, transitionDuration);
    } else {
      transitionComplete();
    }
  }

  dispose(): void {
    Data.removeData(this.element, Modal.DATA_KEY);

    /**
     * `document` has 2 events `Modal.EVENT.FOCUSIN` and `Modal.EVENT.CLICK_DATA_API`
     * Do not move `document` in `htmlElements` array
     * It will remove `Modal.EVENT.CLICK_DATA_API` event that should remain
     */
    EventHandler.off(document, Modal.EVENT.focusin);

    this.element = null;
    this.dialog = null;
    this.backdrop = null;
    this.isShown = null;
    this.ignoreBackdropClick = null;
    this.isTransitioning = null;
  }

  hide(event?: Event): void {
    if (event) {
      event.preventDefault();
    }

    if (!this.isShown || this.isTransitioning) {
      return;
    }

    this.isShown = false;
    const transition = this.element.classList.contains(Modal.CLASSNAME.fade);

    if (transition) {
      this.isTransitioning = true;
    }

    this.setEscapeEvent();

    EventHandler.off(document, Modal.EVENT.focusin);

    this.element.classList.remove(Modal.CLASSNAME.show);

    EventHandler.off(this.element, Modal.EVENT.clickDismiss);
    EventHandler.off(this.dialog, Modal.EVENT.mousedownDismiss);

    if (transition) {
      const transitionDuration = Util.getTransitionDurationFromElement(this.element);

      EventHandler.one(this.element, Util.TRANSITION_END, () => this.hideModal());
      Util.emulateTransitionEnd(this.element, transitionDuration);
    } else {
      this.hideModal();
    }
  }

  show(): void {
    if (this.isShown || this.isTransitioning) {
      return;
    }

    if (this.element.classList.contains(Modal.CLASSNAME.fade)) {
      this.isTransitioning = true;
    }

    this.isShown = true;

    this.setEscapeEvent();

    EventHandler.on(this.element, Modal.EVENT.clickDismiss, Modal.SELECTOR.dataDismiss, event => this.hide(event));

    EventHandler.on(this.dialog, Modal.EVENT.mousedownDismiss, () => {
      EventHandler.one(this.element, Modal.EVENT.mouseupDismiss, event => {
        if (event.target.isEqualNode(this.element)) {
          this.ignoreBackdropClick = true;
        }
      });
    });

    this.showBackdrop(() => this.showElement());
  }

  toggle(): void {
    if (this.isShown) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */
  private registerEvents(): void {
    EventHandler.on(document, Modal.EVENT.clickDataApi, Modal.SELECTOR.dataToggle, (event: Event) => {
      let target: HTMLElement;
      const currentTarget = event.currentTarget as HTMLElement;
      const selector = Util.getSelectorFromElement(event.target as HTMLElement);

      if (selector) {
        target = document.querySelector(selector);
      }

      if (currentTarget.tagName === 'A' || currentTarget.tagName === 'AREA') {
        event.preventDefault();
      }

      const component = Modal.getInstance(target);
      if (component) {
        component.toggle();
      }
    });
  }
}

export class ModalWC extends WebComponentFactory {
  static readonly TAG_NAME = Modal.NAME;

  constructor() {
    super(Modal);
  }

  static init(): void {
    WebComponentFactory.init(ModalWC);
  }
}
