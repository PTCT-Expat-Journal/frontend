/**
 * --------------------------------------------------------------------------
 * NJ: Slider.ts
 * --------------------------------------------------------------------------
 */
import AbstractComponent from '../../globals/ts/abstract-component';
import { Core } from '../../globals/ts/enum';
import Data from '../../globals/ts/data';
import EventHandler from '../../globals/ts/event-handler';
import Manipulator from '../../globals/ts/manipulator';
import Tooltip from '../tooltip';
import Util from '../../globals/ts/util';
import WebComponentFactory from '../../globals/ts/web-component-factory';

export default class Slider extends AbstractComponent {
  static readonly NAME = `${Core.KEY_PREFIX}-slider`;
  protected static readonly DATA_KEY = `${Core.KEY_PREFIX}.slider`;
  private static readonly CLASS_NAME = `${Core.KEY_PREFIX}-slider`;

  protected static readonly SELECTOR = {
    default: `.${Slider.CLASS_NAME}`,
    input: 'input',
    label: 'label'
  };

  // thumb width in pixel
  private static readonly THUMB_WIDTH = 16;

  private static readonly DEFAULT_TYPE = {
    tooltip: 'boolean'
  };

  protected static readonly DEFAULT_OPTIONS = {
    tooltip: false
  };

  private static readonly PERCENT_CONV = 100;

  private static readonly PSEUDO_ELEMS = ['webkit-slider-runnable', 'moz-range', 'ms'];

  // eslint-disable-next-line no-magic-numbers
  private dataId = Number(String(Math.random()).slice(2)) + Date.now();
  private input: HTMLInputElement;
  private tooltip: HTMLElement;

  constructor(element: HTMLElement, options = {}) {
    super(Slider, element, Slider.getOptions(element, options));

    this.input = this.element.querySelector(Slider.SELECTOR.input) as HTMLInputElement;
    this.element.setAttribute('data-id', this.dataId.toString());

    this.refreshProgressValue();
    this.setListeners();

    if (this.options.tooltip) {
      this.addTooltip();
      this.setTooltipListeners();
    }

    Data.setData(element, Slider.DATA_KEY, this);
  }

  private addTooltip(): void {
    this.tooltip = Manipulator.createHtmlNode(Tooltip.DEFAULT_OPTIONS.template) as HTMLElement;
    this.tooltip.classList.add(`${Core.KEY_PREFIX}-tooltip--top`);
    this.tooltip.classList.add('show');
    this.element.insertBefore(this.tooltip, this.element.querySelector(Slider.SELECTOR.label));
    this.refreshTooltipValue();
  }

  private setListeners(): void {
    EventHandler.on(this.element, 'input change keyup', () => {
      this.refreshProgressValue();
    });
  }

  private setTooltipListeners(): void {
    EventHandler.on(this.element, 'input change keyup', () => {
      this.refreshTooltipValue();
    });

    const delay = 100;
    let throttled = false;

    EventHandler.on(document, 'resize', () => {
      if (!throttled) {
        this.refreshTooltipValue();
        throttled = true;
        setTimeout(() => {
          throttled = false;
        }, delay);
      }
    });
  }

  private refreshProgressValue(): void {
    const max = parseInt(this.input.max, 10) || Slider.PERCENT_CONV;
    const min = parseInt(this.input.min, 10) || 0;
    const value = parseInt(this.input.value, 10);

    const perc = Math.floor((Slider.PERCENT_CONV * (value - min)) / (max - min));

    const input: HTMLElement = document.querySelector(`[data-id='${this.dataId}']`);
    input.style.setProperty('--slider-track-position', `${perc}% 100%`);
  }

  private refreshTooltipValue(): void {
    this.tooltip.querySelector(Tooltip.SELECTOR.inner).innerHTML = this.input.value;
    this.replaceTooltip();
  }

  private replaceTooltip(): void {
    const min = this.input.min === '' ? 0 : parseInt(this.input.min, 10);
    // eslint-disable-next-line no-magic-numbers
    const max = this.input.max === '' ? 100 : parseInt(this.input.max, 10);

    const val = parseInt(this.input.value, 10);
    const pos = (val - min) / (max - min);

    this.tooltip.style.left = `${pos * (this.input.offsetWidth - Slider.THUMB_WIDTH) -
      this.tooltip.offsetWidth / 2 +
      Slider.THUMB_WIDTH / 2}px`;
  }

  private static getOptions(element: HTMLElement, options = {}): any {
    options = {
      ...Slider.DEFAULT_OPTIONS,
      ...Manipulator.getDataAttributes(element),
      ...(typeof options === 'object' && options ? options : {})
    };

    Util.typeCheckConfig(Slider.NAME, options, Slider.DEFAULT_TYPE);

    return options;
  }

  dispose(): void {
    Data.removeData(this.element, Slider.DATA_KEY);
    this.element = null;
  }

  static getInstance(element: HTMLElement): Slider {
    return Data.getData(element, Slider.DATA_KEY) as Slider;
  }

  static init(options = {}): Slider[] {
    return super.init(this, options, Slider.SELECTOR.default) as Slider[];
  }
}

export class SliderWC extends WebComponentFactory {
  static readonly TAG_NAME = Slider.NAME;

  constructor() {
    super(Slider);
  }

  static init(): void {
    WebComponentFactory.init(SliderWC);
  }
}
