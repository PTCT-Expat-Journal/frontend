import AbstractComponent from './abstract-component';

export default class WebComponentFactory extends HTMLElement {
  private mutationObserver: MutationObserver;
  private parentNodes: Node[];
  private components: any[];
  private instances: AbstractComponent[];

  constructor(...components: any[]) {
    super();
    this.components = components;
    this.instances = [];
    this.parentNodes = [];
  }

  /**
   * Called when this custom element gets into render tree
   */
  connectedCallback(): void {
    this.setup();
  }

  /**
   * Called when this custom element gets out of render tree
   */
  disconnectedCallback(): void {
    this.instances.forEach(instance => {
      instance.dispose();
    });

    this.instances = null;
  }

  /**
   * Solving the problem of connectCallback being called before children are parsed -> impossible to get innerHTML of web component
   * Source code: https://gist.github.com/franktopel/5d760330a936e32644660774ccba58a7
   */
  private setup(): void {
    // collect the parentNodes
    let el: HTMLElement | (Node & ParentNode) = this; // eslint-disable-line
    while (el.parentNode) {
      el = el.parentNode;
      this.parentNodes.push(el);
    }
    // check if the parser has already passed the end tag of the component
    // in which case this element, or one of its parents, should have a nextSibling
    // if not (no whitespace at all between tags and no nextElementSiblings either)
    // resort to DOMContentLoaded or load having triggered
    if ([this, ...this.parentNodes].some(el => el.nextSibling) || document.readyState !== 'loading') {
      this.childrenAvailableCallback();
    } else {
      this.mutationObserver = new MutationObserver(() => {
        if ([this, ...this.parentNodes].some(el => el.nextSibling) || document.readyState !== 'loading') {
          this.childrenAvailableCallback();
          this.mutationObserver.disconnect();
        }
      });

      this.mutationObserver.observe(this, { childList: true });
    }
  }

  protected childrenAvailableCallback(): void {
    this.components.forEach(Component => {
      const element = this.querySelector(Component.SELECTOR.default);

      if (!element) {
        throw new Error(`Default selector of ${Component.name} not found: ${Component.SELECTOR.default}`);
      }

      this.instances.push(new Component(element));
    });
  }

  protected static init(Component: any): void {
    if (!Component.TAG_NAME) {
      throw new Error(`TAG_NAME property of ${Component.name} class doesn't exists`);
    }

    customElements.define(Component.TAG_NAME, Component); // eslint-disable-line
  }
}
